\documentclass[a4paper,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage{fullpage}
\usepackage{indentfirst}
\usepackage[per-mode=symbol]{siunitx}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{color}
\usepackage{amsmath}
\usepackage{array}
\usepackage[hidelinks]{hyperref}
\usepackage[format=plain,font=it]{caption}
\usepackage{subcaption}
\usepackage{standalone}
\usepackage[nottoc]{tocbibind}
\usepackage[noabbrev,capitalize,nameinlink]{cleveref}
\usepackage{listings}
\usepackage{titlesec}
\usepackage{minted}
\usepackage{booktabs}
\usepackage{csvsimple}
\usepackage{siunitx}
\usepackage[super]{nth}
\usepackage[titletoc]{appendix}
\usepackage{todonotes}

% Custom commands
\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
\newcommand{\code}[1]{\texttt{#1}}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}

\setminted{linenos,breaklines,fontsize=auto}

%\titleformat*{\section}{\normalsize\bfseries}
%\titleformat*{\subsection}{\small\bfseries}
\renewcommand{\thesubsection}{\thesection.\alph{subsection}}
\providecommand*{\listingautorefname}{Listing}
\newcommand*{\Appendixautorefname}{Appendix}
%\crefname{appendix}{Appendix}{Appendices}
%\def\appendixname{Appendix}


%opening
\title{\textbf{ECSE 543 \\ Assignment 3}}
\author{Sean Stappas \\ 260639512}
\date{December \nth{7}, 2017}

\begin{document}
	\sloppy
	\maketitle
	
	\tableofcontents
	
	
	\twocolumn
	
	\section*{Introduction}
	The code for this assignment was created in Python 2.7 and can be seen in \autoref{appendix:code}. To perform the required tasks in this assignment, the \mintinline{python}{Matrix} class from Assignment 1 was used, with useful methods such as add, multiply, transpose, etc. This package can be seen in the \mintinline{python}{matrices.py} file shown in \autoref{lst:matrices}. The only packages used that are not built-in are those for creating the plots for this report, i.e., \mintinline{python}{matplotlib} for plotting. The structure of the rest of the code will be discussed as appropriate for each question. Output logs of the program are provided in \autoref{appendix:logs}.
	
	
	\section{BH Interpolation}
	The source code for the Question 1 program can be seen in the \mintinline{python}{q1.py} file shown in \cref{lst:q1}.
	
	\subsection{Lagrange Polynomials}
	To interpolate 6 points, a \nth{5}-order Lagrange polynomial is needed.
	
	\missingfigure{Interpolate the first 6 points using full-domain
	Lagrange polynomials.}
	
	\subsection{Full-Domain Lagrange Polynomials}
	\missingfigure{Now use the same type of interpolation for the 6
	points at B = 0, 1.3, 1.4, 1.7, 1.8, 1.9.}
	
	The result is not plausible because of the characteristic ``wiggles'' seen when using full-domain Lagrange polynomials over a wide range.
	
	\subsection{Cubic Hermite Polynomials}
	The slopes at each of the 6 points can be approximated by the slope of the straight line passing through the two adjacent points, i.e., the point immediately before and the point after the point of interest. For the boundary points of \SI{0}{\tesla} and \SI{1.9}{\tesla}, the slope of the line formed by the point and one adjacent point can be used.
	
	\section{Magnetic Circuit}
	The source code for the Question 2 program can be seen in the \mintinline{python}{q2.py} file shown in \cref{lst:q2}.
	
	\subsection{Flux Equation}
	The magnetic analog of KVL can be seen in \cref{eq:magnetic_kvl}.

	\begin{equation} \label{eq:magnetic_kvl}
		(\mathcal{R}_a + \mathcal{R}_c) \psi = \mathcal{F}
	\end{equation}
	where $\mathcal{R}_a$ is the reluctance of the air gap, $\mathcal{R}_c$ is the reluctance of the coil, and $\mathcal{F}$ is the magnetomotive force. Plugging in the relevant variables from the problem, we obtain \cref{eq:magnetic_kvl_plug}.

	\begin{equation} \label{eq:magnetic_kvl_plug}
		\left( \frac{L_a}{A \mu_o} + \frac{L_c}{A \mu_c(\psi)} \right) \psi - NI = 0
	\end{equation}
	where $\mu_c(\psi)$ is a function of $\psi$ given by \cref{eq:mu}.
	
	\begin{equation} \label{eq:mu}
		\mu_c(\psi) = \frac{B}{H} = \frac{\psi}{A H}
	\end{equation}
	
	Plugging \cref{eq:mu} into \cref{eq:magnetic_kvl_plug}, we obtain \cref{eq:magnetic_kvl_plug_2}.
	
	\begin{equation} \label{eq:magnetic_kvl_plug_2}
		\left( \frac{L_a}{A \mu_o} + \frac{L_c H}{\psi} \right) \psi - NI = 0
	\end{equation}
	
	Simplifying the terms, we obtain \cref{eq:flux}.
	
	\begin{equation} \label{eq:flux}
		f(\psi) = \frac{L_a \psi}{A \mu_o} + L_c H - NI = 0
	\end{equation}
	
	Finally, if we plug in the values from the question, we obtain \cref{eq:flux_plug}, where the coefficients of the terms are calculated in the \mintinline{python}{q2.py} script shown in \cref{lst:q1}.
	
	\begin{equation} \label{eq:flux_plug}
		\input{latex/flux_equation.txt}
	\end{equation}
	
	\subsection{Newton-Raphson}
	
	\begin{equation} \label{eq:b_psi}
		B = \frac{\psi}{A}
	\end{equation}
	
	\subsection{Successive Substitution}
	
	
	\section{Diode Circuit}
	The source code for the Question 3 program can be seen in the \mintinline{python}{q3.py} file shown in \cref{lst:q3}.
	
	\subsection{Voltage Equations}
	The current-voltage relationship for a diode is given by \cref{eq:diode_iv}.
	
	\begin{equation} \label{eq:diode_iv}
		I = I_s \left( \exp\left[{\frac{qv}{kT}}\right] - 1\right)
	\end{equation}
	
	Let the nodal voltage at the anode of the A diode be denoted by $v_A$ and that of the B diode by $v_B$. Let the current through the circuit be denoted by $I$. The diode equations for A and B can be seen in \cref{eq:diode_A,eq:diode_B}.
	
	\begin{equation} \label{eq:diode_A}
		I = I_{sA} \left( \exp\left[{\frac{q(v_A - v_B)}{kT}}\right] - 1\right)
	\end{equation}
	
	\begin{equation} \label{eq:diode_B}
		I = I_{sB} \left( \exp\left[{\frac{qv_B}{kT}}\right] - 1\right)
	\end{equation}
	
	By KVL, we also have \cref{eq:diode_kvl}, relating $V_A$ and $I$.
	
	\begin{equation} \label{eq:diode_kvl}
		I = \frac{E - v_A}{R}
	\end{equation}
	
	Equating \cref{eq:diode_kvl,eq:diode_A}, we obtain the nonlinear equation for $v_A$, shown in \cref{eq:diode_voltage_A}.
	
	\begin{equation} \label{eq:diode_voltage_A}
	\begin{split}
		&f_A(v_A, v_B) \\
		& = v_A + R I_{sA} \left( \exp\left[{\frac{q(v_A - v_B)}{kT}}\right] - 1\right) - E \\
		& = 0
	\end{split}
	\end{equation}
	
	Equating \cref{eq:diode_A,eq:diode_B}, we obtain the nonlinear equation for $v_B$, shown in \cref{eq:diode_voltage_B}.
	
	\begin{align} \label{eq:diode_voltage_B}
	\begin{split}
		f_B(v_A, v_B) &= I_{sA} \left( \exp\left[{\frac{q(v_A - v_B)}{kT}}\right] - 1\right)\\
		&- I_{sB} \left( \exp\left[{\frac{qv_B}{kT}}\right] - 1\right) = 0
	\end{split}
	\end{align}
	
	The total system of equations can then be expressed by \cref{eq:f_system}.
	
	\begin{equation} \label{eq:f_system}
		\mathbf{f}(\mathbf{v_n}) = 
		\begin{bmatrix}
		f_A(v_A, v_B) \\
		f_B(v_A, v_B)
		\end{bmatrix}
		= \mathbf{0}
	\end{equation}
	
	
	\subsection{Newton-Raphson}
	
	To find an expression for the Jacobian matrix \textbf{F}, we must first find expressions for all the partials of $f_A$ and $f_B$. These are shown in \cref{eq:jacobian_11,eq:jacobian_12,eq:jacobian_21,eq:jacobian_22}.
	
	\begin{equation} \label{eq:jacobian_11}
		\frac{\partial f_A}{\partial v_A} = 1 + R I_{sA} \left( \exp\left[{\frac{q(v_A - v_B)}{kT}}\right]\frac{q}{kT}\right)
	\end{equation}
	
	\begin{equation} \label{eq:jacobian_12}
		\frac{\partial f_A}{\partial v_B} = - R I_{sA} \left( \exp\left[{\frac{q(v_A - v_B)}{kT}}\right]\frac{q}{kT}\right)
	\end{equation}
	
	\begin{equation} \label{eq:jacobian_21}
		\frac{\partial f_B}{\partial v_A} = I_{sA} \left( \exp\left[{\frac{q(v_A - v_B)}{kT}}\right]\frac{q}{kT}\right)
	\end{equation}
	
	\begin{equation} \label{eq:jacobian_22}
	\begin{split}
		\frac{\partial f_B}{\partial v_B} = &-I_{sA} \left( \exp\left[{\frac{q(v_A - v_B)}{kT}}\right]\frac{q}{kT}\right) \\
		&- I_{sB} \left( \exp\left[{\frac{qv_B}{kT}}\right]\frac{q}{kT}\right)
	\end{split}
	\end{equation}
	
	With these equations, the Jacobian matrix \textbf{F} is given by \cref{eq:jacobian}.
	
	\begin{equation} \label{eq:jacobian}
		\textbf{F} = 
		\begin{bmatrix}
		\dfrac{\partial f_A}{\partial v_A} & \dfrac{\partial f_A}{\partial v_B} \\[2ex]
		\dfrac{\partial f_B}{\partial v_A} & \dfrac{\partial f_B}{\partial v_B}
		\end{bmatrix}
	\end{equation}
	
	With this information, we can apply the Newton-Raphson update in matrix form, shown in \cref{eq:newton_raphson}.
	
	\begin{equation} \label{eq:newton_raphson}
		\mathbf{v_n}^{(k + 1)} \leftarrow \mathbf{v_n}^{(k)} - (\mathbf{F}^{(k)})^{-1} \mathbf{f}^{(k)}
	\end{equation}
	
	The code performing this update is in the \code{newton\_raphson.py} script and can be seen in \cref{lst:newton_raphson}. The error $\epsilon$ in \textbf{f} is defined as \SI{1e-9}{}, where the 2-norm of \textbf{f} is used to compare to the error. The code is executed in the \code{q3.py} script shown in \cref{lst:q3}, with output shown in \cref{lst:q3_log}. 
	
	
	\begin{table}[!htb]
		\centering
		\caption{Node voltages and \textbf{f} values at every iteration of Newton-Raphson.}
		\begin{tabular}{r}
			\SI{1e-1}{}
		\end{tabular}
		\label{table:q3}
	\end{table}
	
	\section{Function Integration}
	The source code for the Question 4 program can be seen in the \mintinline{python}{q4.py} file shown in \cref{lst:q4}.
	
	\subsection{Cosine Integration}
	
	The integral $I$ we wish to solve is shown in \cref{eq:cos_x_integral}.
	
	\begin{equation} \label{eq:cos_x_integral}
		I = \int\limits_{0}^{1} \cos x dx 
	\end{equation}
	
	To use Gauss-Legendre integration, the $[0, 1]$ range of $x$ must be mapped to the $[-1, 1]$ range of $\zeta$. This mapping between $x$ and $\zeta$ is given by \cref{eq:x_zeta}.
	
	\begin{equation} \label{eq:x_zeta}
		x = \frac{1}{2} (\zeta + 1)
	\end{equation}
	
	The updated integral equation is then given by \cref{eq:cos_zeta_integral}.
	
	\begin{equation} \label{eq:cos_zeta_integral}
		I =  \frac{1}{2} \int\limits_{-1}^{1} \cos \left[\frac{1}{2} (\zeta + 1)\right] d\zeta 
	\end{equation}
	
	
	The equation for the absolute error used is shown in \cref{eq:error}, where $I_{actual}$ is the actual value of the integral, and $I_{approx}$ is the approximate value computed by Gauss-Legendre integration.
	
	\begin{equation} \label{eq:error}
		E = | I_{actual}  - I_{approx}|
	\end{equation}
	
	\missingfigure{Plot log10(E) versus log10(N) for N=1, 2,…, 20, where E is the absolute	error in the computed integral.}
	
	\subsection{Log Integration}
	
	The integral $I$ we woulwish to solve is shown in \cref{eq:log_x_integral}.
	
	\begin{equation} \label{eq:log_x_integral}
		I = \int\limits_{0}^{1} \log x dx 
	\end{equation}
	
	Using \cref{eq:x_zeta} for the $\log$ function, we obtain the integral shown in \cref{eq:log_zeta_integral}.
	
	\begin{equation} \label{eq:log_zeta_integral}
		I =  \frac{1}{2} \int\limits_{-1}^{1} \log \left[\frac{1}{2} (\zeta + 1)\right] d\zeta 
	\end{equation}
	
	\missingfigure{Repeat part (a) for the function log(x), only this time plot for N=10, 20,…200.}
	
	\subsection{Log Integration Improvement}
	
	
%	\begin{figure}[!htb]
%		\centering
%		\includegraphics[width=0.5\columnwidth]{plots/q1_circuit_1.pdf}
%		\caption
%		{Test circuit 1 with labeled nodes.}
%		\label{fig:q1_circuit_1}
%	\end{figure}
%
%	\begin{table}[!htb]
%		\centering
%		\caption{Voltage at labeled nodes of circuit 1.}
%		\csvautobooktabular{csv/q1_circuit_1.csv}
%		\label{table:q1_circuit_1}
%	\end{table}
%
%	\begin{equation} \label{eq:functional}
%		W_i = \frac{1}{2} U_{con_i}^T S U_{con_i}
%	\end{equation}
	
	\onecolumn
	
	\begin{appendices}
		
		\section{Code Listings} \label{appendix:code}
		
		\setminted{linenos,breaklines,fontsize=\footnotesize}
		
		\begin{center}
			\captionof{listing}{Custom matrix package (\texttt{matrices.py}).}
			\inputminted{python}{../matrices.py}
			\label{lst:matrices}
		\end{center}
	
		\begin{center}
			\captionof{listing}{Question 1 (\texttt{q1.py}).}
			\inputminted{python}{../q1.py}
			\label{lst:q1}
		\end{center}
	
		\begin{center}
			\captionof{listing}{Question 2 (\texttt{q2.py}).}
			\inputminted{python}{../q2.py}
			\label{lst:q2}
		\end{center}
		
		
		\begin{center}
			\captionof{listing}{Question 3 (\texttt{q3.py}).}
			\inputminted{python}{../q3.py}
			\label{lst:q3}
		\end{center}
	
		\begin{center}
			\captionof{listing}{Newton-Raphson (\texttt{newton\_raphson.py}).}
			\inputminted{python}{../newton_raphson.py}
			\label{lst:newton_raphson}
		\end{center}

		\begin{center}
			\captionof{listing}{Question 4 (\texttt{q4.py}).}
			\inputminted{python}{../q4.py}
			\label{lst:q4}
		\end{center}
	
		\section{Output Logs} \label{appendix:logs}
		
		\begin{center}
			\captionof{listing}{Output of Question 1 program (\texttt{q1.txt}).}
			\inputminted{pycon}{logs/q1.txt}
			\label{lst:q1_log}
		\end{center}
	
		\begin{center}
			\captionof{listing}{Output of Question 2 program (\texttt{q2.txt}).}
			\inputminted{pycon}{logs/q2.txt}
			\label{lst:q2_log}
		\end{center}
	
		\begin{center}
			\captionof{listing}{Output of Question 3 program (\texttt{q3.txt}).}
			\inputminted{pycon}{logs/q3.txt}
			\label{lst:q3_log}
		\end{center}
	
		\begin{center}
			\captionof{listing}{Output of Question 4 program (\texttt{q4.txt}).}
			\inputminted{pycon}{logs/q4.txt}
			\label{lst:q4_log}
		\end{center}

	\end{appendices}

\end{document}
